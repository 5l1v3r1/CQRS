\hypertarget{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions}{}\doxysection{Cqrs.\+Sql.\+Data\+Stores.\+Sql\+Data\+Store\+Extensions Class Reference}
\label{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions}\index{Cqrs.Sql.DataStores.SqlDataStoreExtensions@{Cqrs.Sql.DataStores.SqlDataStoreExtensions}}


A collection of extension methods for I\+Data\+Store$<$\+T\+Data$>$  


\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static I\+Queryable$<$ T\+Entity $>$ \mbox{\hyperlink{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions_a77e339885a9e26ff6bcf5b5bbe24b19d_a77e339885a9e26ff6bcf5b5bbe24b19d}{Where$<$ T\+Entity, T\+Db\+Entity $>$}} (this \mbox{\hyperlink{interfaceCqrs_1_1DataStores_1_1IDataStore}{I\+Data\+Store}}$<$ T\+Entity $>$ data\+Store, Expression$<$ Func$<$ T\+Entity, bool $>$$>$ predicate)
\begin{DoxyCompactList}\small\item\em Use this one... Filters a sequence of values based on a predicate. \end{DoxyCompactList}\item 
static T\+Entity \mbox{\hyperlink{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions_aff2943b536ef4fa182ce8b5194d65d86_aff2943b536ef4fa182ce8b5194d65d86}{Single$<$ T\+Entity, T\+Db\+Entity $>$}} (this I\+Enumerable$<$ T\+Entity $>$ data\+Store)
\begin{DoxyCompactList}\small\item\em Use this one... Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A collection of extension methods for I\+Data\+Store$<$\+T\+Data$>$ 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions_aff2943b536ef4fa182ce8b5194d65d86_aff2943b536ef4fa182ce8b5194d65d86}\label{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions_aff2943b536ef4fa182ce8b5194d65d86_aff2943b536ef4fa182ce8b5194d65d86}} 
\index{Cqrs.Sql.DataStores.SqlDataStoreExtensions@{Cqrs.Sql.DataStores.SqlDataStoreExtensions}!Single$<$ TEntity, TDbEntity $>$@{Single$<$ TEntity, TDbEntity $>$}}
\index{Single$<$ TEntity, TDbEntity $>$@{Single$<$ TEntity, TDbEntity $>$}!Cqrs.Sql.DataStores.SqlDataStoreExtensions@{Cqrs.Sql.DataStores.SqlDataStoreExtensions}}
\doxysubsubsection{\texorpdfstring{Single$<$ TEntity, TDbEntity $>$()}{Single< TEntity, TDbEntity >()}}
{\footnotesize\ttfamily static T\+Entity Cqrs.\+Sql.\+Data\+Stores.\+Sql\+Data\+Store\+Extensions.\+Single$<$ T\+Entity, T\+Db\+Entity $>$ (\begin{DoxyParamCaption}\item[{this I\+Enumerable$<$ T\+Entity $>$}]{data\+Store }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Use this one... Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence. 

\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T\+Db\+Entity} : {\em class}]\item[{\em T\+Db\+Entity} : {\em new()}]\item[{\em T\+Entity} : {\em new()}]\end{description}
\end{Desc}
\mbox{\Hypertarget{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions_a77e339885a9e26ff6bcf5b5bbe24b19d_a77e339885a9e26ff6bcf5b5bbe24b19d}\label{classCqrs_1_1Sql_1_1DataStores_1_1SqlDataStoreExtensions_a77e339885a9e26ff6bcf5b5bbe24b19d_a77e339885a9e26ff6bcf5b5bbe24b19d}} 
\index{Cqrs.Sql.DataStores.SqlDataStoreExtensions@{Cqrs.Sql.DataStores.SqlDataStoreExtensions}!Where$<$ TEntity, TDbEntity $>$@{Where$<$ TEntity, TDbEntity $>$}}
\index{Where$<$ TEntity, TDbEntity $>$@{Where$<$ TEntity, TDbEntity $>$}!Cqrs.Sql.DataStores.SqlDataStoreExtensions@{Cqrs.Sql.DataStores.SqlDataStoreExtensions}}
\doxysubsubsection{\texorpdfstring{Where$<$ TEntity, TDbEntity $>$()}{Where< TEntity, TDbEntity >()}}
{\footnotesize\ttfamily static I\+Queryable$<$T\+Entity$>$ Cqrs.\+Sql.\+Data\+Stores.\+Sql\+Data\+Store\+Extensions.\+Where$<$ T\+Entity, T\+Db\+Entity $>$ (\begin{DoxyParamCaption}\item[{this \mbox{\hyperlink{interfaceCqrs_1_1DataStores_1_1IDataStore}{I\+Data\+Store}}$<$ T\+Entity $>$}]{data\+Store,  }\item[{Expression$<$ Func$<$ T\+Entity, bool $>$$>$}]{predicate }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Use this one... Filters a sequence of values based on a predicate. 

\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T\+Db\+Entity} : {\em class}]\item[{\em T\+Db\+Entity} : {\em new()}]\end{description}
\end{Desc}
